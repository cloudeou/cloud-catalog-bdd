# Telus-BDD <!-- omit in toc -->

## _BDD test automation framework_ <!-- omit in toc -->

[![N|Solid](https://images.ctfassets.net/fikanzmkdlqn/5NoHRB1q6lrNzSSpekhrG5/cf22f3d7d9e82aed5e79659800458b57/TELUS_TAGLINE_HORIZONTAL_EN.svg)](https://www.telus.com/en/)

**Telus-BDD** is a lightweight crossplatform compatible Node.js based test automation framework, built upon jest and cucumber, providing features as parallel tests execution, contexts, environments, database bootstraping and others.

## Table of Contents <!-- omit in toc -->

- [Installation](#installation)
- [Initialization](#initialization)
  - [bdd.config](#bddconfig)
  - [CLI (launch script)](#cli-launch-script)
  - [TypeScript Initialization Example](#typescript-initialization-example)
- [Abilities](#abilities)
  - [Basic](#basic)
    - [Steps](#steps)
    - [Featues](#featues)
  - [Advanced](#advanced)
    - [Contexts](#contexts)
    - [Tag Parameters](#tag-parameters)
    - [DBbootstrap & DBbootstrapParams & RunTimes](#dbbootstrap--dbbootstrapparams--runtimes)
    - [Dependent Features](#dependent-features)
    - [Environments](#environments)
    - [Reporting](#reporting)
- [Webapp](#webapp)

## Installation

Create `.npmrc` file in your project and add it to `.gitignore`.
Add the following to `.npmrc`:

```
//npm.pkg.github.com/:_authToken=AUTH_TOKEN
@telus-bdd:registry=https://npm.pkg.github.com
```

You can also add the first line with access token to your global `~/.npmrc` file, in that way you can safely push local `.npmrc` file to your repo, since it does not contain the token.
Run

```sh
npm install @telus-bdd/telus-bdd
```

Note: the token could change. To get more information about access, please contact:

- dlFIFATestAutomationDevelopers@telus.com

## Initialization

This command will create **bdd** folder with all the structure and **bdd.config** file (you can choose to generate it in .json or .js). You just need to create npm script with it, or even launch straight from terminal if you use unix os.

```json
  "scripts": {
    "bdd-init": "bdd-init"
  }
```

```sh
npm run bdd-init
```

or

```sh
bdd-init
```

You can also add `-f` or `--fast` flag to skip all questions, the full structure (with js syntax by default).

`!Note: if you launch commands straight from terminal you should add -- before passing any command line arguments`.

### bdd.config

Config file is autogenerated based on your answers in init, the only costant fields are **featuresPath**, **stepsPath** and **threadsNumber**, others are optional.
If you want to change location of any framework folder or config inside your project, you can do so and just change the relative path in **bdd.config**

```javascript
{
"featuresPath": "./bdd/features",    // path to your features directory
"stepsPath": "./bdd/steps",      // path to your steps directory
"db": {     // database configuration for DB bootstrap
  "user": "",
  "passwd": "",
  "host": "",
  "port": 0
},
"envsPath": "",     // path to your environments directory
"contextsPath": "",     // path to your contexts directory
"threadsNumber": 5,     // default number of parallel threads
"testOrderPath": "./bdd/testOrder.config.json",  // path to test order config for dependent features
"bootstrapPath": "./bdd/DBBootstrap.config.js",  // path to DB bootstrap config
"reporters": ["default"], // reporter config
"testDataGUI": { // test data interface ui
  "host": "",
  "port": 0
}
}
```

### CLI (launch script)

You can pass the following arguments to launch:

1. `--featuresPath`
2. `--stepsPath`
3. `--envsPath`
4. `--contextsPath`
5. `--threadsNumber`
6. `--testOrderPath`
7. `--bootstrapPath`
8. `--config`
9. `--suiteName`
10. `--bddEnv`
11. `--useUReport`

- You can create a number of configs with, for example, different databases, or specific features and steps folders, and pass `--config` argument, this will override default config.
- If you want to override separate values of config you can use arguments 1 to 7 to do so.
  `--threadsNumber` argument sets number of parallel processes that the tests will run in.
- Pass `--suiteName` argument (equals to some identificator tag parameter see Tag Parameters) to run one specific test or a specific group of tests.
- You can use `--env` argument if you use different environments it will set the vlaue as process.env.bddEnv

Launch command:

```sh
bdd --suiteName=SN15 [--bddEnv=] [--config=] [--threadsNumber=] [--testOrderPath=] [--bootstrapPath=] [--contextsPath=] [--envsPath=] [--stepsPath=] [--featuresPath=] [--useUReport=]
```

You just need to create npm script with this command, or even launch straight from terminal if you use unix os.

```json
  "scripts": {
    "bdd:start": "bdd"
  }
```

```sh
npm run bdd:start
```

or

```sh
bdd
```

`!Note: if you launch commands straight from terminal you should add -- before passing any command line arguments`.

### TypeScript Initialization Example

Please open the `example` folder in our [documentation repo](https://github.com/telus-bdd/telus-bdd-docs/tree/master/example) to see the tutorial.

## Abilities

### Basic

The logic behind steps and features is the same one cucumber and Gherkin have, you can go [here](https://cucumber.io/docs/gherkin/reference/) for detailed description.

#### Steps

Steps are the building blocks of .feature files, each step is function(given, when, then, and, but) with step name and callback. In feature file you use names of steps and then these names are mapped with according callbacks.
Steps are stored in `./bdd/steps` folder by default, but you can change their location and write new path to **bdd.config**. Let's start a very simple example, first we need to create steps.

```javascript
// spaceX.steps.ts
const { featureContext } = require('@telus-bdd/telus-bdd');
import { StepDefinitions } from 'jest-cucumber';
import Identificators from '../contexts/Identificators';
import SpaseXContext from '../contexts/SpaseXContext';

const backendSteps: StepDefinitions = ({ given, and, when, then }) => {
  let spaseXContext = (): SpaseXContext =>
    featureContext().getContextById(Identificators.spaseXContext);

  given('star ship name is', (name) => {
    expect(name).not.toBe(null);
    spaceXContext().setStarShipName(name);
  });
  when('build star ship', () => {
    const name = spaceXContext().getStarShipName();
    const starShip = new StarShip(name);
    spaceXContext().setStarShip(starShip);
  });
  then('launch star ship', () => {
    const starShip = spaceXContext().getStarShip();
    const launched = starShip.launch();
    expect(launched).toBeTruthy();
  });
};
```

Pro Tip!
: Telus-BDD uses jest for running tests, but it is extended by usage of _jest-expect-message_ library. That means you can use messages for failures right inside `expect` construction like in the example below:

```javascript
...
  then('launch star ship', () => {
    const starShip = spaceXContext().getStarShip();
    const launched = starShip.launch();
    expect(launched, "Oh no, starship did not launch!").toBeTruthy();
  });
...
```

After you finished implementing your steps files you have to add them to `index` files of steps directory for framework to see and use them, in this way you can control all of the steps you are using in one place and load everything if you don't need it.

Export steps from steps file:
Javascript:

```javascript
module.exports = { backendSteps };
```

Typescript:

```javascript
export const backendSteps: StepDefinitions ...
```

Import them to `index` file:
Javascript:

```javascript
const backendSteps = require('./backenSteps.steps');
module.exports = [backendSteps];
```

Typescript:

```javascript
import backendSteps from './backendSteps.steps';
export default [backendSteps];
```

#### Featues

Features are actual test files with _.feature_ extension written in Gherkin language with some light enhancements, described in advanced abilities. Feature files are combined from steps.
Features are stored in `./bdd/features` folder by default, but you can change their location and write new path to **bdd.config**. So now we create a feature file for our example.

```gherkin
@spaceX
@SNlanunches
@SN15
Feature: Launch SN15
  Scenario: Star Ship lifecycle
    Given star ship name is SN15
    When build star ship
    Then launch star ship
```

### Advanced

#### Contexts

Contexts are in-memory data storages during runtime, they can save any data between scenarios in feature file or even between several feature files if you use **Dependent Features**.
To use them you will need to choose contexts option during init.
Init will create `./bdd/contexts` directory in your project and `Identifiators.ts` or `Identificators.js` object in it. (You can always create these manually, and add **contextsPath** filed to your **bdd.config**).
Now you are ready to create your custom contexts, to do that you'll need to create a file with class, create new identificator for context in `Identificators` and then add identificator field with this value in your custom context class, we recommend using simple class structure with private fields and getter/setter methods for them, let's create the context we used in our example.
`Please note: the key and value pair in Identificators should coincide`

**Typescript**

```javascript
//Identificators.ts
export const Identificators = {
  spaceXContext: 'spaceXContext',
};
```

```typescript
//SpaceXContext.ts
import { Identificators } from './Identificators';

export default class SpaseXContext {
  public identificator = Identificators.spaceXContext;
  private starShip: StarShip;
  private starShipName: string;
  public getStarShip() {
    return this.starShip;
  }
  public setStarShip(ship: StarShip) {
    this.starShip = ship;
  }
  public getStarShipName() {
    return this.starShipName;
  }
  public setStarShipName(name: string) {
    this.starShipName = ship;
  }
}
```

**Javascript**

```javascript
//Identificators.js
const Identificators = {
  spaceXContext: 'spaceXContext',
};
module.exports = { Identificators };
```

```javascript
//SpaceXContext.js
const { Identificators } = require('./Identificators');

class SpaseXContext {
  public identificator = Identificators.spaceXContext;
  private starShip;
  private starShipName;
  public getStarShip() {
    return this.starShip;
  }
  public setStarShip(ship) {
    this.starShip = ship;
  }
  public getStarShipName() {
    return this.starShipName;
  }
  public setStarShipName(name) {
    this.starShipName = ship;
  }
}
module.exports = SpaseXContext;
```

You can use contexts in your step files with FeatureContext class from the framework and your Identificators:

```javascript
const { featureContext } = require("@telus-bdd/telus-bdd");
import { StepDefinitions } from "jest-cucumber";
import Identificators from "../contexts/Identificators";
import SpaseXContext from "../contexts/SpaseXContext";

const backendSteps: StepDefinitions = ({ given, and, when, then }) => {
  let spaseXContext = (): SpaseXContext =>
    featureContext().getContextById(Identificators.spaseXContext);

```

#### Tag Parameters

Tag parameters are a generic the way to specify some data for a feature file. Tag parameters are devided in two parts:

- identificator parameters (first 3 tags)
- key-value parameters

**Identificator parameters** serve as the 3 level identification for a feature file, e.g. as in our example you have the following strucure in your features folder:

```
features/
  spaceX/
    SNlaunches/
      SN15.feature
```

So **identificator parameters** in a feature file this will look like:

```gherkin
@spaceX
@SNlanunches
@SN15
```

If you don't need 3 levels you can just add any symbol to a tag, like `@-` or `@1`, but remember that **first 3 tags** are dedicated to identificate the feature file.

**Key-value parameters** serve to specify DBbootsrap and RunTimes features. They are going right after **identificator parameters**, for example:

```gherkin
@DBbootstrap=retrieve-sn-data
@runTimes=10
```

#### DBbootstrap & DBbootstrapParams & RunTimes

`Note: to use this functinality you have to answer the according question while init`

Database bootstrap allows you to pass the test data to your test from a number of rows in a database. In this way you can create only one feature file and execute any number of test cases in it.
Currently you can use only Postgres database for your application, since it is one of the best crossplatform solutions, Postgres should be suitable for vast majority of cases.
Run times specifies how many times the feature file should be executed, combined with database bootstrap specifies how many rows should be retrieved from a database.

To use it, firstly you will need to fill in database config, find `db` property in `bdd.config.json`:

```json
{
  "db": {
    // database configuration for DB bootstrap
    "user": "",
    "passwd": "",
    "host": "",
    "port": 0
  }
}
```

Secondly you will need to add a query to `DBbootstrap.config.js`, it will be autogenerated if you choose to use database.
This config is created as a `.js` javascript file, it contains default exported object, with methods for bootstraps.
These methods must meet 3 requiremtns:

- the key in object must be the same as name of bootstrap you specify in `@DBbootstrap` tag parameter
- each method must return a string (valid sql query)
- each method must receive a single argument, which is an object of parameters for a bootstrap (e.g. `params`)

So as long as the file is `.js` file you can include in your methods many things to make your bootstraps more functional and comprehensive, for example:

- Run additional validation of bootstrap parameters, or any other code
- Import your methods from other files and just map them with the aliases
- Use ES6 string templating and ternar operators to modify your query depending on parameters

Bootstrap for our example is:

```javascript
module.exports = {
  retrieveSnData: (params) =>
    `
    SELECT * FROM sn_data
    ${params.launchPad ? `WHERE launch_pad=${params.launchPad}` : ``}
    LIMIT ${params.runTimes}
    `,
};
```

> #### @DBbootstrapParams tag parameter
>
> By default an object of parameters that is passed to your bootstrap method includes two parameters:
>
> - `runTimes` - value of `@runTimes` tag parameter
> - `bddEnv` - value of passed environment, if specified (with `--bddEnv` argument in cli)
>   You can specify any other parameters you would like to use in your query via `@DBbootstrapParams` tag parameter, you should set its value with a valid JSON, as following:
>
> ```gherkin
> @DBbootstrapParams={"engines":12,"launchPad":"boca-chica"}
> ```
>
> `Note: you can't use spaces in @DBbootstrapParams value`
>
> And then get these values in your method from `params` object by the exact same keys:
>
> ```javascript
> module.exports = {
>   retrieveSnData: (params) =>
>     `
>    SELECT * FROM sn_data
>    ${params.launchPad ? `WHERE launch_pad=${params.launchPad}` : ``}
>    LIMIT ${params.runTimes}
>    `,
> };
> ```

Then in you feature file you just need to add tag parameters (`@DBbootstrap`, `@runTimes`, `@DBbootstrapParams` if needed):

```gherkin
@spaceX
@SNlanunches
@SN15
@DBbootstrap=retrieve-sn-data
@runTimes=10
@DBbootstrapParams={"engines":12,"launchPad":"boca-chica"}
Feature: Launch SN15
  Scenario: Star Ship lifecycle
    Given star ship name is @name
    When build star ship
    Then launch star ship
```

As you may see we can now set test data via variables, using @ like `@name`, these variables corresponde with column names in database, so for this case we have the following:
Framework will retrieve 10 rows from database, that contain `name` column and launch your feature file for 10 times, each time paasing in different values of `name`.

Now, how do you access this data, the framework creates an enviromental variable `bootstrapData`, it is stringified array of DBbootstrap data sets(rows) (it is an array in case you need to run DBbootstrap .features in Dependent Features mode, in that case all of them will be executed in one process, so you will have an array of e.g. 10 data sets(rows)). To access the data in steps you'd need to fetch it as following:

```typescript
given('star ship name is', (name) => {
  const shipName = JSON.parse(process.env.bootstrapData)[0][name]; // bootstrapData[0]['@name']
  expect(shipName).not.toBe(null);
  spaceXContext().setStarShipName(shipName);
});
```

Databases bootstrap must be used in couple with run times, but run times could be used independently if you need to run the same feature file for multiple times by any reason.

#### Dependent Features

Dependent Features are used if you need to pass some context data not just between steps, but between feature files, the framework forms chains from dependent features and these chains are being executed inside one thread in an order that you have set.
To use that you will need `testOrder.config.json`, it will be autogenerated during init, if you approve according option. Let's look into some examples:
You have the following features folder structure:

```
features/
  1/
    1.1.feature
    1.2.feature
  2/
    2.1.feature
    2.2.feature
    2.2.feature
```

Accordingly feature files have tags:

```gherkin
@-
@1
@1.1
Feature: 1.1
```

```gherkin
@-
@1
@1.2
Feature: 1.2
```

```gherkin
@-
@2
@2.1
Feature: 2.1
```

```gherkin
@-
@2
@2.2
Feature: 2.2
```

```gherkin
@-
@2
@2.3
Feature: 2.3
```

Then we can create chains of dependent features in `testOrder.config.json` as following:

```json
"@1": ["@1.1", "@1.2"],
"@2": ["@2.3", "@2.2", "@2.1"]
```

#### Environments

You may need different environments for yout tests to run in, in that case, you can create number of configs for each environment (urls, tokens, users, etc.) and put them in a folder. Then, when launching tests you can set --bddEnv command line argument with any string value to pass environment to framework, and it will set an enviromental variable that you can use in your code `process.env.bddEnv`.

```bash
bdd --suiteName=SN15 --bddEnv=env1
```

Currently it is not crucial to write your envs directory to `bdd.config.json` `envsPath`, but in the future the framework may start using your enviromental configs, so consider it as best practice.

#### Reporting

Reporters are configured the same way as in jest, you can look it up in all details [here](https://jestjs.io/ru/docs/configuration#reporters-arraymodulename--modulename-options).
So you just need to write an array of any reporters to `reporters` field in `bdd.config.json`.

As a reporter we also provide `@telus/agent-js-jest` which works with UReport portal, the module is installed with the framework. However, this particular reporter is not added to reporters field, but specified seperately. So you can add it to config as following:

```json
{
  "useUReport": true,
  "uReportConfig": {
    "token": "", // token of your UReport instance
    "launch": "", // project name to launch (should be the same as project)
    "endpoint": "", // endpoint of Ureport api for module to use
    "project": "", // your project name
    "description": "", // description of your project
    "attributes": [
      {
        "value": ""
      }
    ]
  }
}
```

## Webapp

In order to make sence of your data, we created webapp. To configure it, you need to include in your `bdd.config.json` as following:

```json
"webapp": {
  "host": "localhost",
  "port": 3000,
}
```

In order to connect to the webapp, you should proceed login page with authentication, present your x_id and password.

**_Webapp consist of 4 parts:_**

- **Table Listing**

  **_your-host/table-listing_**

  You can choose table from connected database in `bdd.config.json` and get table of data that correspondce to database.

- **Query Tool**

  **_your-host/query-tool_**

  You can write any query in the environment and it will work as it is in the database. Also for better code readability you can choose preffered theme in code environment.

- **File Importer**

  **_your-host/file-importer_**

  Using XLSX or CSV files you can create tables or insert data into already created tables in the database configured in `bdd.config.json`.

  To insert data you should prepare an XLSX or CSV file that will correspond to the table in the database (column name file == column name DB)

  To create a new table, you should select the _"New Table"_ option from the dropdown, specify a name for the new table and upload an XLSX or CSV file with corresponding data for a new table. Each column from the file will be mapped to the new table columns. After file upload, a popup will be opened, in which you should specify data types for each column presented in the file.

- **Running test using endpoint**

  You can run tests from webapp with help of two endpoints (GET and POST)

  **GET:**

  In order to invoke testing on the GET, you should go to the

  **_your-host/test-spawner_?suiteName=_your-suiteName_&bddEnv=_your-bddEnv_&threads=_your-number-of-threads_**

  All parameters are optional.

  After you submit the url, you will see output of testing in the terminal.

  **POST:**

  To access make POST request, first you should authenticate with x_id and password, by making POST request with your data on

  **\*your-host/login**

  With following params:

  ```json
  "x_id": "your x_id",
  "pass": "your pass"
  ```

  In order to invoke testing on the POST, you should make POST request on the

  **_your-host/test-spawner_**

  With the following body params:

  ```json
  "suiteName": "your suite name",
  "bddEnv": "your bddEnv",
  "threads": 1,
  ```

  Number of threads can be anything. All parameters are optional.

  After you submit the request, you will see output of testing in the terminal.
